{% extends "base.html" %}
{% block content %}
<div class="split">
  <section class="card" style="padding: 12px;">
    <div class="row between">
      <div>
        <h2>Live</h2>
        <div class="muted">OBS stream</div>
      </div>
      <div class="row">
        <span class="muted">Stream:</span>
        <span id="streamStatus" class="mono">checking…</span>
        <span id="streamTracks" class="muted"></span>
      </div>
    </div>

    <div class="preview" style="margin-top: 12px;">
      <div id="liveWrap" style="position: relative;">
        <iframe
          id="playerFrame"
          title="Live feed"
          src="{{ webrtc_player_url }}"
          allow="autoplay; fullscreen; picture-in-picture"
          allowfullscreen
          referrerpolicy="no-referrer"
        ></iframe>
        <div id="detectRect" style="position:absolute; display:none; border:3px solid rgba(46,196,182,0.95); border-radius:12px; box-shadow:0 0 0 2px rgba(0,0,0,0.25) inset; pointer-events:none;"></div>
      </div>
    </div>
    <div class="row" style="margin-top: 10px;">
      <a class="muted" href="{{ webrtc_player_url }}" target="_blank" rel="noopener">Open player in new tab</a>
    </div>
  </section>

  <aside class="card" style="padding: 12px;">
    <h2 style="margin-bottom: 8px;">Latest Win</h2>

    <div class="row">
      <span class="muted">Active draw:</span>
      <span id="activeDraw" class="mono">…</span>
    </div>

    <div class="row">
      <span class="muted">Colors:</span>
      <span id="latestColors" class="mono"></span>
    </div>

    <div class="row">
      <span class="muted">Time:</span>
      <span id="latestTime" class="mono"></span>
    </div>

    <div class="row">
      <span class="muted">Detector:</span>
      <span id="detStatus" class="mono">…</span>
    </div>
    <div class="row">
      <span class="muted">Error:</span>
      <span id="detError" class="mono"></span>
    </div>

    <div class="row">
      <a class="muted" href="/draw">Manage Draws (enable/disable)</a>
    </div>

    <div class="hr"></div>

    <div class="row between">
      <h2 style="margin: 0;">History</h2>
      <button class="btn" id="clearHistory">Clear</button>
    </div>

    <table class="table" style="margin-top: 8px;">
      <thead>
        <tr>
          <th style="width: 150px;">Time (PH)</th>
          <th>Colors</th>
          <th style="width: 70px;">Conf</th>
        </tr>
      </thead>
      <tbody id="resultRows"></tbody>
    </table>
  </aside>
</div>

<script>
  const phFmt = new Intl.DateTimeFormat('en-PH', {
    timeZone: 'Asia/Manila',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: 'numeric',
    minute: '2-digit',
    second: '2-digit',
    hour12: true,
  });

  function fmtPh(ts) {
    try {
      const d = new Date(ts);
      if (isNaN(d.getTime())) return '';
      return phFmt.format(d);
    } catch (_) {
      return '';
    }
  }

  async function pollStream() {
    try {
      const r = await fetch('/api/stream/status');
      const j = await r.json();
      const pub = !!j.publishing;
      document.getElementById('streamStatus').textContent = pub ? 'connected' : 'disconnected';
      const tracks = Array.isArray(j.tracks) ? j.tracks.join(' · ') : '';
      document.getElementById('streamTracks').textContent = tracks ? `(${tracks})` : '';
    } catch (_) {
      document.getElementById('streamStatus').textContent = 'unknown';
      document.getElementById('streamTracks').textContent = '';
    }
    setTimeout(pollStream, 1000);
  }
  pollStream();

  async function pollWebrtc() {
    try {
      const r = await fetch('/api/webrtc/sessions');
      const j = await r.json();
      const items = Array.isArray(j.items) ? j.items : [];
      document.getElementById('webrtcSessions').textContent = String(items.length);
      if (items.length > 0) {
        const last = items[items.length - 1];
        const lc = last.localCandidate ? String(last.localCandidate) : '';
        const rc = last.remoteCandidate ? String(last.remoteCandidate) : '';
        document.getElementById('webrtcIce').textContent = `${lc}  <=  ${rc}`;
      } else {
        document.getElementById('webrtcIce').textContent = '';
      }
    } catch (_) {
      document.getElementById('webrtcSessions').textContent = 'unknown';
      document.getElementById('webrtcIce').textContent = '';
    }
    setTimeout(pollWebrtc, 1500);
  }
  pollWebrtc();

  async function pollDetector() {
    try {
      const r = await fetch('/api/detector/status');
      const j = await r.json();
      const status = j.running ? (j.connected ? 'running' : 'running (disconnected)') : 'stopped';
      document.getElementById('detStatus').textContent = status;
      document.getElementById('detError').textContent = j.last_error ? String(j.last_error) : '';

      const ad = j.active_draw ? `${j.active_draw.name}` : '(none)';
      document.getElementById('activeDraw').textContent = ad;

      const lr = j.last_result;
      document.getElementById('latestColors').textContent = lr ? lr.colors.join(', ') : '';
      document.getElementById('latestTime').textContent = lr ? fmtPh(lr.timestamp) : '';

      // Show a rectangle on the live player when detection is currently happening.
      // We treat "detected" as "we saw a valid RESULT ROI recently".
      const detRect = document.getElementById('detectRect');
      const wrap = document.getElementById('liveWrap');
      const cfg = j.config || {};
      const rr = cfg.result_roi || null;
      const lastDet = (typeof j.last_detected_time === 'number') ? j.last_detected_time : null;
      const isHot = lastDet !== null && ((Date.now() / 1000) - lastDet) < 1.2;
      if (rr && isHot && wrap) {
        const rect = wrap.getBoundingClientRect();
        const scaleX = rect.width / (cfg.width || 1920);
        const scaleY = rect.height / (cfg.height || 1080);
        detRect.style.left = (rr.x * scaleX) + 'px';
        detRect.style.top = (rr.y * scaleY) + 'px';
        detRect.style.width = (rr.w * scaleX) + 'px';
        detRect.style.height = (rr.h * scaleY) + 'px';
        detRect.style.display = 'block';
      } else {
        detRect.style.display = 'none';
      }
    } catch (_) {
      document.getElementById('detStatus').textContent = 'unknown';
      document.getElementById('activeDraw').textContent = 'unknown';
      document.getElementById('latestColors').textContent = '';
      document.getElementById('latestTime').textContent = '';
      document.getElementById('detError').textContent = '';
      const detRect = document.getElementById('detectRect');
      if (detRect) detRect.style.display = 'none';
    }

    try {
      const r = await fetch('/api/detector/results');
      const j = await r.json();
      const items = Array.isArray(j.items) ? j.items : [];
      const rows = items.slice(-20).reverse();
      const tbody = document.getElementById('resultRows');
      tbody.innerHTML = '';
      for (const it of rows) {
        const tr = document.createElement('tr');
        const tdT = document.createElement('td');
        tdT.className = 'mono';
        tdT.textContent = it.timestamp ? fmtPh(it.timestamp) : '';
        const tdC = document.createElement('td');
        tdC.className = 'mono';
        tdC.textContent = (it.colors || []).join(', ');
        const tdConf = document.createElement('td');
        tdConf.className = 'mono right';
        tdConf.textContent = (typeof it.confidence === 'number') ? it.confidence.toFixed(2) : '';
        tr.appendChild(tdT);
        tr.appendChild(tdC);
        tr.appendChild(tdConf);
        tbody.appendChild(tr);
      }
    } catch (_) {
      // ignore
    }

    setTimeout(pollDetector, 1000);
  }
  pollDetector();

  document.getElementById('clearHistory').addEventListener('click', async () => {
    await fetch('/api/detector/results/clear', { method: 'POST' });
  });
</script>
{% endblock %}
