{% extends "base.html" %}
{% block content %}
<section class="card">
  <h2>Dashboard</h2>

  <div class="row">
    <span class="muted">Stream status:</span>
    <span id="streamStatus" class="mono">checking…</span>
    <span id="streamTracks" class="muted"></span>
    <span id="streamSource" class="muted"></span>
  </div>

  <details style="margin-top: 10px;">
    <summary>Connection Debug</summary>
    <div style="margin-top: 8px;">
      <div class="row">
        <span class="muted">WebRTC sessions:</span>
        <span id="webrtcSessions" class="mono">checking…</span>
      </div>
      <div class="row">
        <span class="muted">Latest ICE:</span>
        <span id="webrtcIce" class="mono"></span>
      </div>
    </div>
  </details>

  <details style="margin-top: 10px;" open>
    <summary>Result Detection (OpenCV)</summary>
    <div style="margin-top: 8px;">
      <div class="row">
        <span class="muted">RTSP (used for detection):</span>
        <span class="mono">{{ rtsp_url }}</span>
      </div>

      <div class="row">
        <button class="btn primary" id="detStart">Start Detection</button>
        <button class="btn" id="detStop">Stop</button>
        <span class="muted">Status:</span>
        <span id="detStatus" class="mono">checking…</span>
      </div>

      <div class="row">
        <button class="btn" id="detSnap">Capture Snapshot</button>
        <a class="muted" href="/api/detector/snapshot.jpg" target="_blank" rel="noopener">open snapshot</a>
      </div>

      <div class="row" style="margin-top: 6px;">
        <span class="muted">ROI draw target:</span>
        <select id="roiSelect" style="max-width: 180px;">
          <option value="1">Box 1 (left)</option>
          <option value="2">Box 2 (middle)</option>
          <option value="3">Box 3 (right)</option>
        </select>
        <span class="muted">Drag on the snapshot to set the box.</span>
      </div>

      <div class="preview" id="snapWrap" style="margin-top: 10px; position: relative;">
        <img id="snapshotImg" alt="Snapshot" style="width: 100%; display: block;" />
        <div id="roiBox1" class="roi-box b1"></div>
        <div id="roiBox2" class="roi-box b2"></div>
        <div id="roiBox3" class="roi-box b3"></div>
        <div id="roiDraw" class="roi-draw"></div>
      </div>

      <div class="row" style="margin-top: 10px;">
        <span class="muted">ROI Boxes (x,y,w,h) left→right:</span>
      </div>
      <div class="row">
        <input id="b1" class="mono" placeholder="x,y,w,h" style="max-width: 260px;" />
        <input id="b2" class="mono" placeholder="x,y,w,h" style="max-width: 260px;" />
        <input id="b3" class="mono" placeholder="x,y,w,h" style="max-width: 260px;" />
        <button class="btn" id="detSave">Save ROI</button>
      </div>

      <div class="row">
        <span class="muted">Latest result:</span>
        <span id="detLast" class="mono"></span>
      </div>

      <div class="row">
        <span class="muted">History:</span>
      </div>
      <div class="status">
        <div id="detHistory" class="mono"></div>
      </div>
    </div>
  </details>

  <details style="margin-top: 10px;" open>
    <summary>OBS Settings (Recommended: WHIP / WebRTC)</summary>
    <div style="margin-top: 8px;">
      <div class="row">
        <span class="muted">Service:</span>
        <span class="mono">WHIP</span>
      </div>
      <div class="row">
        <span class="muted">Server:</span>
        <span class="mono">{{ whip_url }}</span>
      </div>
      <div class="row">
        <span class="muted">Stream key:</span>
        <span class="mono">(empty)</span>
      </div>
      <div class="row">
        <span class="muted">Tip:</span>
        <span class="muted">WHIP avoids the RTMP→WebRTC audio mismatch and is the lowest-latency path.</span>
      </div>
    </div>
  </details>

  <details style="margin-top: 10px;">
    <summary>OBS Settings (Alternate: RTMP)</summary>
    <div style="margin-top: 8px;">
      <div class="row">
        <span class="muted">Service:</span>
        <span class="mono">Custom…</span>
      </div>
      <div class="row">
        <span class="muted">Server:</span>
        <span class="mono">{{ rtmp_server }}</span>
      </div>
      <div class="row">
        <span class="muted">Stream key:</span>
        <span class="mono">{{ rtmp_stream_key }}</span>
      </div>
      <div class="row">
        <span class="muted">Note:</span>
        <span class="muted">If the player says “peer connection closed”, it’s often because your H.264 has B-frames enabled. Set B-frames = 0 and Profile = Baseline/Constrained Baseline.</span>
      </div>
    </div>
  </details>

  <div class="preview" style="margin-top: 12px;">
    <iframe
      id="playerFrame"
      title="Live feed"
      src="{{ webrtc_player_url }}"
      allow="autoplay; fullscreen; picture-in-picture"
      allowfullscreen
      referrerpolicy="no-referrer"
    ></iframe>
  </div>

  <div class="row" style="margin-top: 10px;">
    <a class="muted" href="{{ webrtc_player_url }}" target="_blank" rel="noopener">Open player in new tab</a>
  </div>
</section>

<script>
  async function pollStatus() {
    try {
      const r = await fetch('/api/stream/status');
      const j = await r.json();
      const pub = !!j.publishing;
      document.getElementById('streamStatus').textContent = pub ? 'connected (publishing)' : 'disconnected';
      const tracks = Array.isArray(j.tracks) ? j.tracks.join(' · ') : '';
      document.getElementById('streamTracks').textContent = tracks ? `(${tracks})` : '';
      const sourceType = j && j.source && j.source.type ? String(j.source.type) : '';
      document.getElementById('streamSource').textContent = sourceType ? `source: ${sourceType}` : '';
    } catch (_) {
      document.getElementById('streamStatus').textContent = 'unknown';
      document.getElementById('streamTracks').textContent = '';
      document.getElementById('streamSource').textContent = '';
    }
    setTimeout(pollStatus, 1000);
  }
  pollStatus();

  async function pollWebrtc() {
    try {
      const r = await fetch('/api/webrtc/sessions');
      const j = await r.json();
      const items = Array.isArray(j.items) ? j.items : [];
      document.getElementById('webrtcSessions').textContent = String(items.length);

      if (items.length > 0) {
        const last = items[items.length - 1];
        const lc = last.localCandidate ? String(last.localCandidate) : '';
        const rc = last.remoteCandidate ? String(last.remoteCandidate) : '';
        document.getElementById('webrtcIce').textContent = `${lc}  <=  ${rc}`;
      } else {
        document.getElementById('webrtcIce').textContent = '';
      }
    } catch (_) {
      document.getElementById('webrtcSessions').textContent = 'unknown';
      document.getElementById('webrtcIce').textContent = '';
    }
    setTimeout(pollWebrtc, 1500);
  }
  pollWebrtc();

  function parseBox(v) {
    const parts = String(v || '').split(',').map(s => s.trim()).filter(Boolean);
    if (parts.length !== 4) return null;
    const nums = parts.map(p => Number(p));
    if (nums.some(n => !Number.isFinite(n))) return null;
    return { x: Math.trunc(nums[0]), y: Math.trunc(nums[1]), w: Math.trunc(nums[2]), h: Math.trunc(nums[3]) };
  }

  async function loadDetConfig() {
    const r = await fetch('/api/detector/config');
    const j = await r.json();
    const boxes = j.boxes || [];
    if (boxes.length === 3) {
      document.getElementById('b1').value = `${boxes[0].x},${boxes[0].y},${boxes[0].w},${boxes[0].h}`;
      document.getElementById('b2').value = `${boxes[1].x},${boxes[1].y},${boxes[1].w},${boxes[1].h}`;
      document.getElementById('b3').value = `${boxes[2].x},${boxes[2].y},${boxes[2].w},${boxes[2].h}`;
    }
    window.__detectorCfg = j;
    renderRois();
  }

  function renderRois() {
    const cfg = window.__detectorCfg || {};
    const boxes = cfg.boxes || [];
    const img = document.getElementById('snapshotImg');
    const wrap = document.getElementById('snapWrap');

    if (!img || !wrap || !img.naturalWidth || !img.naturalHeight || boxes.length !== 3) {
      return;
    }

    const rect = img.getBoundingClientRect();
    const scaleX = rect.width / img.naturalWidth;
    const scaleY = rect.height / img.naturalHeight;

    function place(el, b) {
      el.style.left = (b.x * scaleX) + 'px';
      el.style.top = (b.y * scaleY) + 'px';
      el.style.width = (b.w * scaleX) + 'px';
      el.style.height = (b.h * scaleY) + 'px';
      el.style.display = 'block';
    }

    place(document.getElementById('roiBox1'), boxes[0]);
    place(document.getElementById('roiBox2'), boxes[1]);
    place(document.getElementById('roiBox3'), boxes[2]);
  }

  async function pollDet() {
    try {
      const r = await fetch('/api/detector/status');
      const j = await r.json();
      const status = j.running ? (j.connected ? 'running (connected)' : 'running (disconnected)') : 'stopped';
      document.getElementById('detStatus').textContent = status;
      document.getElementById('detLast').textContent = j.last_result ? JSON.stringify(j.last_result.colors) : '';
    } catch (_) {
      document.getElementById('detStatus').textContent = 'unknown';
    }
    try {
      const r = await fetch('/api/detector/results');
      const j = await r.json();
      const items = Array.isArray(j.items) ? j.items : [];
      const lines = items.slice(-10).reverse().map(it => `${it.timestamp}  ${it.colors.join(', ')}  (conf=${(it.confidence||0).toFixed(2)})`);
      document.getElementById('detHistory').textContent = lines.join('\n');
    } catch (_) {
      document.getElementById('detHistory').textContent = '';
    }
    setTimeout(pollDet, 1000);
  }

  document.getElementById('detStart').addEventListener('click', async () => {
    await fetch('/api/detector/start', { method: 'POST' });
  });
  document.getElementById('detStop').addEventListener('click', async () => {
    await fetch('/api/detector/stop', { method: 'POST' });
  });
  document.getElementById('detSave').addEventListener('click', async () => {
    const b1 = parseBox(document.getElementById('b1').value);
    const b2 = parseBox(document.getElementById('b2').value);
    const b3 = parseBox(document.getElementById('b3').value);
    if (!b1 || !b2 || !b3) {
      alert('Invalid ROI. Use: x,y,w,h');
      return;
    }
    const payload = { boxes: [b1, b2, b3] };
    const r = await fetch('/api/detector/config', { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
    window.__detectorCfg = await r.json();
    renderRois();
  });
  document.getElementById('detSnap').addEventListener('click', async () => {
    const img = document.getElementById('snapshotImg');
    img.src = `/api/detector/snapshot.jpg?ts=${Date.now()}`;
  });

  // ROI drag-to-set on the snapshot.
  (function setupRoiDrag() {
    const img = document.getElementById('snapshotImg');
    const draw = document.getElementById('roiDraw');
    let dragging = false;
    let startX = 0, startY = 0;

    function toNatural(clientX, clientY) {
      const r = img.getBoundingClientRect();
      const x = (clientX - r.left) * (img.naturalWidth / r.width);
      const y = (clientY - r.top) * (img.naturalHeight / r.height);
      return { x: Math.max(0, Math.min(img.naturalWidth, x)), y: Math.max(0, Math.min(img.naturalHeight, y)) };
    }

    function setDrawRect(x0, y0, x1, y1) {
      const r = img.getBoundingClientRect();
      const scaleX = r.width / img.naturalWidth;
      const scaleY = r.height / img.naturalHeight;
      const left = Math.min(x0, x1) * scaleX;
      const top = Math.min(y0, y1) * scaleY;
      const w = Math.abs(x1 - x0) * scaleX;
      const h = Math.abs(y1 - y0) * scaleY;
      draw.style.left = left + 'px';
      draw.style.top = top + 'px';
      draw.style.width = w + 'px';
      draw.style.height = h + 'px';
      draw.style.display = 'block';
    }

    img.addEventListener('load', () => {
      renderRois();
    });

    img.addEventListener('mousedown', (e) => {
      if (!img.naturalWidth) return;
      dragging = true;
      const p = toNatural(e.clientX, e.clientY);
      startX = p.x;
      startY = p.y;
      setDrawRect(startX, startY, startX, startY);
    });
    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const p = toNatural(e.clientX, e.clientY);
      setDrawRect(startX, startY, p.x, p.y);
    });
    window.addEventListener('mouseup', async (e) => {
      if (!dragging) return;
      dragging = false;
      draw.style.display = 'none';
      const p = toNatural(e.clientX, e.clientY);
      const x0 = Math.round(Math.min(startX, p.x));
      const y0 = Math.round(Math.min(startY, p.y));
      const w = Math.max(1, Math.round(Math.abs(p.x - startX)));
      const h = Math.max(1, Math.round(Math.abs(p.y - startY)));
      const val = `${x0},${y0},${w},${h}`;
      const which = document.getElementById('roiSelect').value;
      if (which === '1') document.getElementById('b1').value = val;
      if (which === '2') document.getElementById('b2').value = val;
      if (which === '3') document.getElementById('b3').value = val;
      renderRois();
    });
  })();

  loadDetConfig().catch(() => {});
  pollDet();
</script>
{% endblock %}
