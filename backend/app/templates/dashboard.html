{% extends "base.html" %}
{% block content %}
<section class="card">
  <h2>Dashboard</h2>

  <div class="row">
    <span class="muted">Stream status:</span>
    <span id="streamStatus" class="mono">checking…</span>
    <span id="streamTracks" class="muted"></span>
    <span id="streamSource" class="muted"></span>
  </div>

  <details style="margin-top: 10px;">
    <summary>Connection Debug</summary>
    <div style="margin-top: 8px;">
      <div class="row">
        <span class="muted">WebRTC sessions:</span>
        <span id="webrtcSessions" class="mono">checking…</span>
      </div>
      <div class="row">
        <span class="muted">Latest ICE:</span>
        <span id="webrtcIce" class="mono"></span>
      </div>
    </div>
  </details>

  <details style="margin-top: 10px;" open>
    <summary>Result Detection (OpenCV)</summary>
    <div style="margin-top: 8px;">
      <div class="row">
        <span class="muted">RTSP (used for detection):</span>
        <span class="mono">{{ rtsp_url }}</span>
      </div>

      <div class="row">
        <button class="btn primary" id="detStart">Start Detection</button>
        <button class="btn" id="detStop">Stop</button>
        <span class="muted">Status:</span>
        <span id="detStatus" class="mono">checking…</span>
      </div>

      <div class="row" style="margin-top: 10px;">
        <button class="btn" id="drawRoi">Draw Box On Video</button>
        <button class="btn" id="clearRoi">Clear</button>
        <span class="muted">Draw one rectangle covering all 3 result colors.</span>
      </div>
      <div class="row">
        <span class="muted">ROI (x,y,w,h):</span>
        <input id="roiAll" class="mono" placeholder="x,y,w,h" style="max-width: 320px;" />
        <button class="btn" id="detSave">Save ROI</button>
      </div>

      <div class="row">
        <span class="muted">Latest result:</span>
        <span id="detLast" class="mono"></span>
      </div>

      <div class="row">
        <span class="muted">History:</span>
      </div>
      <div class="status">
        <div id="detHistory" class="mono"></div>
      </div>
    </div>
  </details>

  <details style="margin-top: 10px;" open>
    <summary>OBS Settings (Recommended: WHIP / WebRTC)</summary>
    <div style="margin-top: 8px;">
      <div class="row">
        <span class="muted">Service:</span>
        <span class="mono">WHIP</span>
      </div>
      <div class="row">
        <span class="muted">Server:</span>
        <span class="mono">{{ whip_url }}</span>
      </div>
      <div class="row">
        <span class="muted">Stream key:</span>
        <span class="mono">(empty)</span>
      </div>
      <div class="row">
        <span class="muted">Tip:</span>
        <span class="muted">WHIP avoids the RTMP→WebRTC audio mismatch and is the lowest-latency path.</span>
      </div>
    </div>
  </details>

  <details style="margin-top: 10px;">
    <summary>OBS Settings (Alternate: RTMP)</summary>
    <div style="margin-top: 8px;">
      <div class="row">
        <span class="muted">Service:</span>
        <span class="mono">Custom…</span>
      </div>
      <div class="row">
        <span class="muted">Server:</span>
        <span class="mono">{{ rtmp_server }}</span>
      </div>
      <div class="row">
        <span class="muted">Stream key:</span>
        <span class="mono">{{ rtmp_stream_key }}</span>
      </div>
      <div class="row">
        <span class="muted">Note:</span>
        <span class="muted">If the player says “peer connection closed”, it’s often because your H.264 has B-frames enabled. Set B-frames = 0 and Profile = Baseline/Constrained Baseline.</span>
      </div>
    </div>
  </details>

  <div class="preview" style="margin-top: 12px;">
    <div id="videoWrap" style="position: relative;">
      <iframe
        id="playerFrame"
        title="Live feed"
        src="{{ webrtc_player_url }}"
        allow="autoplay; fullscreen; picture-in-picture"
        allowfullscreen
        referrerpolicy="no-referrer"
      ></iframe>
      <div id="overlay" style="position:absolute; inset:0; pointer-events:none;">
        <div id="roiBox" class="roi-box b1" style="display:none;"></div>
        <div id="roiDrawRect" class="roi-draw"></div>
      </div>
    </div>
  </div>

  <div class="row" style="margin-top: 10px;">
    <a class="muted" href="{{ webrtc_player_url }}" target="_blank" rel="noopener">Open player in new tab</a>
  </div>
</section>

<script>
  async function pollStatus() {
    try {
      const r = await fetch('/api/stream/status');
      const j = await r.json();
      const pub = !!j.publishing;
      document.getElementById('streamStatus').textContent = pub ? 'connected (publishing)' : 'disconnected';
      const tracks = Array.isArray(j.tracks) ? j.tracks.join(' · ') : '';
      document.getElementById('streamTracks').textContent = tracks ? `(${tracks})` : '';
      const sourceType = j && j.source && j.source.type ? String(j.source.type) : '';
      document.getElementById('streamSource').textContent = sourceType ? `source: ${sourceType}` : '';
    } catch (_) {
      document.getElementById('streamStatus').textContent = 'unknown';
      document.getElementById('streamTracks').textContent = '';
      document.getElementById('streamSource').textContent = '';
    }
    setTimeout(pollStatus, 1000);
  }
  pollStatus();

  async function pollWebrtc() {
    try {
      const r = await fetch('/api/webrtc/sessions');
      const j = await r.json();
      const items = Array.isArray(j.items) ? j.items : [];
      document.getElementById('webrtcSessions').textContent = String(items.length);

      if (items.length > 0) {
        const last = items[items.length - 1];
        const lc = last.localCandidate ? String(last.localCandidate) : '';
        const rc = last.remoteCandidate ? String(last.remoteCandidate) : '';
        document.getElementById('webrtcIce').textContent = `${lc}  <=  ${rc}`;
      } else {
        document.getElementById('webrtcIce').textContent = '';
      }
    } catch (_) {
      document.getElementById('webrtcSessions').textContent = 'unknown';
      document.getElementById('webrtcIce').textContent = '';
    }
    setTimeout(pollWebrtc, 1500);
  }
  pollWebrtc();

  function parseBox(v) {
    const parts = String(v || '').split(',').map(s => s.trim()).filter(Boolean);
    if (parts.length !== 4) return null;
    const nums = parts.map(p => Number(p));
    if (nums.some(n => !Number.isFinite(n))) return null;
    return { x: Math.trunc(nums[0]), y: Math.trunc(nums[1]), w: Math.trunc(nums[2]), h: Math.trunc(nums[3]) };
  }

  async function loadDetConfig() {
    const r = await fetch('/api/detector/config');
    const j = await r.json();
    const rr = j.result_roi;
    if (rr) {
      document.getElementById('roiAll').value = `${rr.x},${rr.y},${rr.w},${rr.h}`;
    }
    window.__detectorCfg = j;
    renderRois();
  }

  function renderRois() {
    const cfg = window.__detectorCfg || {};
    const rr = cfg.result_roi;
    const roiEl = document.getElementById('roiBox');
    const wrap = document.getElementById('videoWrap');
    const overlay = document.getElementById('overlay');
    if (!rr || !roiEl || !wrap || !overlay || !cfg.width || !cfg.height) {
      if (roiEl) roiEl.style.display = 'none';
      return;
    }

    const rect = overlay.getBoundingClientRect();
    const scaleX = rect.width / cfg.width;
    const scaleY = rect.height / cfg.height;
    roiEl.style.left = (rr.x * scaleX) + 'px';
    roiEl.style.top = (rr.y * scaleY) + 'px';
    roiEl.style.width = (rr.w * scaleX) + 'px';
    roiEl.style.height = (rr.h * scaleY) + 'px';
    roiEl.style.display = 'block';
  }

  async function pollDet() {
    try {
      const r = await fetch('/api/detector/status');
      const j = await r.json();
      const status = j.running ? (j.connected ? 'running (connected)' : 'running (disconnected)') : 'stopped';
      document.getElementById('detStatus').textContent = status;
      document.getElementById('detLast').textContent = j.last_result ? JSON.stringify(j.last_result.colors) : '';
    } catch (_) {
      document.getElementById('detStatus').textContent = 'unknown';
    }
    try {
      const r = await fetch('/api/detector/results');
      const j = await r.json();
      const items = Array.isArray(j.items) ? j.items : [];
      const lines = items.slice(-10).reverse().map(it => `${it.timestamp}  ${it.colors.join(', ')}  (conf=${(it.confidence||0).toFixed(2)})`);
      document.getElementById('detHistory').textContent = lines.join('\n');
    } catch (_) {
      document.getElementById('detHistory').textContent = '';
    }
    setTimeout(pollDet, 1000);
  }

  document.getElementById('detStart').addEventListener('click', async () => {
    await fetch('/api/detector/start', { method: 'POST' });
  });
  document.getElementById('detStop').addEventListener('click', async () => {
    await fetch('/api/detector/stop', { method: 'POST' });
  });
  document.getElementById('detSave').addEventListener('click', async () => {
    const rr = parseBox(document.getElementById('roiAll').value);
    if (!rr) {
      alert('Invalid ROI. Use: x,y,w,h');
      return;
    }
    const payload = { result_roi: rr };
    const r = await fetch('/api/detector/config', { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
    window.__detectorCfg = await r.json();
    renderRois();
  });

  function setDrawMode(on) {
    const overlay = document.getElementById('overlay');
    const wrap = document.getElementById('videoWrap');
    if (!overlay || !wrap) return;
    overlay.style.pointerEvents = on ? 'auto' : 'none';
    wrap.style.cursor = on ? 'crosshair' : 'default';
  }

  document.getElementById('drawRoi').addEventListener('click', () => {
    setDrawMode(true);
  });
  document.getElementById('clearRoi').addEventListener('click', () => {
    document.getElementById('roiAll').value = '';
    const roiEl = document.getElementById('roiBox');
    if (roiEl) roiEl.style.display = 'none';
  });

  // ROI drag-to-set on the live video overlay.
  (function setupOverlayDrag() {
    const overlay = document.getElementById('overlay');
    const draw = document.getElementById('roiDrawRect');
    if (!overlay || !draw) return;

    let dragging = false;
    let startX = 0, startY = 0;

    function toFrame(clientX, clientY) {
      const cfg = window.__detectorCfg || {};
      const r = overlay.getBoundingClientRect();
      const x = (clientX - r.left) * (cfg.width / r.width);
      const y = (clientY - r.top) * (cfg.height / r.height);
      return { x: Math.max(0, Math.min(cfg.width, x)), y: Math.max(0, Math.min(cfg.height, y)) };
    }

    function setDrawRect(x0, y0, x1, y1) {
      const cfg = window.__detectorCfg || {};
      const r = overlay.getBoundingClientRect();
      const scaleX = r.width / cfg.width;
      const scaleY = r.height / cfg.height;
      const left = Math.min(x0, x1) * scaleX;
      const top = Math.min(y0, y1) * scaleY;
      const w = Math.abs(x1 - x0) * scaleX;
      const h = Math.abs(y1 - y0) * scaleY;
      draw.style.left = left + 'px';
      draw.style.top = top + 'px';
      draw.style.width = w + 'px';
      draw.style.height = h + 'px';
      draw.style.display = 'block';
    }

    overlay.addEventListener('mousedown', (e) => {
      const cfg = window.__detectorCfg || {};
      if (!cfg.width || !cfg.height) return;
      dragging = true;
      const p = toFrame(e.clientX, e.clientY);
      startX = p.x;
      startY = p.y;
      setDrawRect(startX, startY, startX, startY);
    });

    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const p = toFrame(e.clientX, e.clientY);
      setDrawRect(startX, startY, p.x, p.y);
    });

    window.addEventListener('mouseup', (e) => {
      if (!dragging) return;
      dragging = false;
      draw.style.display = 'none';
      const p = toFrame(e.clientX, e.clientY);
      const x0 = Math.round(Math.min(startX, p.x));
      const y0 = Math.round(Math.min(startY, p.y));
      const w = Math.max(1, Math.round(Math.abs(p.x - startX)));
      const h = Math.max(1, Math.round(Math.abs(p.y - startY)));
      document.getElementById('roiAll').value = `${x0},${y0},${w},${h}`;
      setDrawMode(false);
      // render locally without saving yet
      const cfg = window.__detectorCfg || {};
      cfg.result_roi = { x: x0, y: y0, w, h };
      window.__detectorCfg = cfg;
      renderRois();
    });
  })();

  loadDetConfig().catch(() => {});
  pollDet();
</script>
{% endblock %}
